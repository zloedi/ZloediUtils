// Copyright (c) 2021 Stoiko Todorov
// This work is licensed under the terms of the MIT license.  
// For a copy, see https://opensource.org/licenses/MIT.

#if UNITY_STANDALONE || UNITY_2021_1_OR_NEWER || SDL

// apple II font

#if SDL
using System.Runtime.InteropServices;
using static SDL2.SDL;
using static SDL2.SDL.SDL_TextureAccess;
using GalliumMath;
using SDLPorts;
#else
using UnityEngine;
#endif
using System;

public static class AppleFont {

public const int APPLEIIF_WIDTH = 96;
public const int APPLEIIF_HEIGHT = 64;
public const int APPLEIIF_CLMS = 16;
public const int APPLEIIF_ROWS = 8;
public const int APPLEIIF_CW = (APPLEIIF_WIDTH/APPLEIIF_CLMS);
public const int APPLEIIF_CH = (APPLEIIF_HEIGHT/APPLEIIF_ROWS);

public static readonly byte [] bitmap = new byte[APPLEIIF_WIDTH * APPLEIIF_HEIGHT / 8] {
0x0e,0xf1,0x38,0xcf,0xf7,0x79,0x91,0x03,0x45,0x41,0x14,0x39,0x91,0x12,0x45,0x51,
0x10,0x04,0x11,0x01,0x25,0xc1,0x16,0x45,0x55,0x14,0x05,0x51,0x10,0x04,0x11,0x01,
0x15,0x41,0x35,0x45,0x5d,0xf4,0x04,0xd1,0xf3,0x04,0x1f,0x01,0x0d,0x41,0x55,0x45,
0xcd,0x17,0x05,0x51,0x10,0x64,0x11,0x01,0x15,0x41,0x94,0x45,0x41,0x14,0x45,0x51,
0x10,0x44,0x11,0x11,0x25,0x41,0x14,0x45,0x5e,0xf4,0x38,0xcf,0x17,0x78,0x91,0xe3,
0x44,0x5f,0x14,0x39,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x8f,0xf3,0x38,0x5f,0x14,0x45,0x51,0xf4,0x7d,0xc0,0x07,0x00,0x51,0x14,0x45,0x44,
0x14,0x45,0x51,0x04,0x0d,0x01,0x06,0x00,0x51,0x14,0x05,0x44,0x14,0x45,0x8a,0x82,
0x0c,0x02,0x46,0x00,0x4f,0xf4,0x38,0x44,0x14,0x55,0x04,0x41,0x0c,0x04,0xa6,0x00,
0x41,0x55,0x40,0x44,0x14,0x55,0x0a,0x21,0x0c,0x08,0x16,0x01,0x41,0x92,0x44,0x44,
0xa4,0x6c,0x11,0x11,0x0c,0x10,0x06,0x00,0x81,0x15,0x39,0x84,0x43,0x44,0x11,0xf1,
0x7d,0xc0,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,
0x00,0xa1,0x28,0xc4,0x20,0x10,0x04,0x41,0x00,0x00,0x00,0x00,0x00,0xa1,0x28,0xde,
0x54,0x10,0x02,0x52,0x11,0x00,0x00,0x40,0x00,0xa1,0x7c,0x05,0x52,0x10,0x01,0xe4,
0x10,0x00,0x00,0x20,0x00,0x01,0x28,0x0e,0x21,0x00,0x01,0x44,0x7c,0xc0,0x07,0x10,
0x00,0x01,0x7c,0x94,0x50,0x01,0x01,0xe4,0x10,0x04,0x00,0x08,0x00,0x00,0x28,0x4f,
0x96,0x00,0x02,0x52,0x11,0x04,0x00,0x04,0x00,0x01,0x28,0x04,0x66,0x01,0x04,0x41,
0x00,0x02,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x0e,0xe1,0x7c,0xc8,0xc7,0x7d,0x8e,0x03,0x00,0x08,0x20,0x38,0x91,0x11,0x41,0x4c,
0x20,0x40,0x51,0x04,0x00,0x04,0x40,0x44,0x19,0x01,0x21,0xca,0x13,0x20,0x51,0x44,
0x10,0xc2,0x87,0x20,0x15,0xc1,0x30,0x09,0xf4,0x10,0x8e,0x07,0x00,0x01,0x00,0x11,
0x13,0x21,0x40,0x1f,0x14,0x09,0x11,0x44,0x10,0xc2,0x87,0x10,0x11,0x11,0x44,0x48,
0x14,0x09,0x11,0x02,0x10,0x04,0x40,0x00,0x8e,0xf3,0x39,0x88,0xe3,0x08,0xce,0x01,
0x08,0x08,0x20,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x0e,0xf1,0x38,0xcf,0xf7,0x79,0x91,0x03,0x45,0x41,0x14,0x39,0x91,0x12,0x45,0x51,
0x10,0x04,0x11,0x01,0x25,0xc1,0x16,0x45,0x55,0x14,0x05,0x51,0x10,0x04,0x11,0x01,
0x15,0x41,0x35,0x45,0x5d,0xf4,0x04,0xd1,0xf3,0x04,0x1f,0x01,0x0d,0x41,0x55,0x45,
0xcd,0x17,0x05,0x51,0x10,0x64,0x11,0x01,0x15,0x41,0x94,0x45,0x41,0x14,0x45,0x51,
0x10,0x44,0x11,0x11,0x25,0x41,0x14,0x45,0x5e,0xf4,0x38,0xcf,0x17,0x78,0x91,0xe3,
0x44,0x5f,0x14,0x39,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x8f,0xf3,0x38,0x5f,0x14,0x45,0x51,0xf4,0x7d,0xc0,0x07,0x00,0x51,0x14,0x45,0x44,
0x14,0x45,0x51,0x04,0x0d,0x01,0x06,0x00,0x51,0x14,0x05,0x44,0x14,0x45,0x8a,0x82,
0x0c,0x02,0x46,0x00,0x4f,0xf4,0x38,0x44,0x14,0x55,0x04,0x41,0x0c,0x04,0xa6,0x00,
0x41,0x55,0x40,0x44,0x14,0x55,0x0a,0x21,0x0c,0x08,0x16,0x01,0x41,0x92,0x44,0x44,
0xa4,0x6c,0x11,0x11,0x0c,0x10,0x06,0x00,0x81,0x15,0x39,0x84,0x43,0x44,0x11,0xf1,
0x7d,0xc0,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,
0x02,0x10,0x00,0x10,0xc0,0x00,0x01,0x81,0x04,0x06,0x00,0x00,0x04,0x10,0x00,0x10,
0x20,0x01,0x01,0x00,0x04,0x04,0x00,0x00,0x88,0xf3,0x78,0x9e,0x23,0x38,0x8f,0xc1,
0x44,0xc4,0xf6,0x38,0x00,0x14,0x05,0x51,0xf4,0x44,0x11,0x81,0x24,0x44,0x15,0x45,
0x80,0x17,0x05,0xd1,0x27,0x44,0x11,0x81,0x1c,0x44,0x15,0x45,0x40,0x14,0x05,0x51,
0x20,0x78,0x11,0x81,0x24,0x44,0x15,0x45,0x80,0xf7,0x78,0x9e,0x27,0x40,0x91,0x93,
0x44,0x4e,0x14,0x39,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x60,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x70,0xc4,0x61,0x01,0x00,0x00,0x00,0x02,
0x00,0x00,0x00,0x00,0x18,0x04,0xd3,0x54,0x8f,0xd7,0x79,0x4f,0x14,0x45,0x51,0xf4,
0x19,0x04,0x03,0x28,0x51,0x34,0x04,0x42,0x14,0x45,0x4a,0x84,0x0c,0x04,0x06,0x54,
0x51,0x14,0x38,0x42,0x14,0x55,0x44,0x44,0x18,0x04,0x03,0x28,0x8f,0x17,0x40,0x52,
0xa6,0x54,0x8a,0x27,0x18,0x04,0x03,0x54,0x01,0x14,0x3c,0x8c,0x45,0x6c,0x11,0xf4,
0x71,0xc4,0x01,0x00,0x01,0x04,0x00,0x00,0x00,0x00,0x80,0x03,0x00,0x04,0x00,0x00,
};


public static void MeasureString( string s, out float w, out float h,
                                            float scale = 1, float extraX = 0, float extraY = 0 ) { 
    float cw = scale * ( APPLEIIF_CW + extraX );
    float ch = scale * ( APPLEIIF_CH + extraY );

    float x = 0, y = ch, max = 0;
    foreach ( var c in s ) {
        if ( c == '\n' ) {
            x = 0;
            y += ch;
        } else {
            x += cw;
            max = Math.Max( max, x );
        }
    }
    w = max;
    h = y;
}

static Texture2D _texture;
public static Texture2D GetTexture() {
    if ( _texture ) {
        return _texture;
    }

    _texture = CreateTexture( APPLEIIF_WIDTH, APPLEIIF_HEIGHT );

    int srcW = APPLEIIF_WIDTH / 8;
    for ( int y = 0; y < APPLEIIF_HEIGHT; y++ ) {
        for ( int x = 0; x < srcW; x++ ) {
            int b = bitmap[x + y * srcW];
            for ( int i = 0; i < 8; i++ ) {
                int alpha = ( b & ( 1 << i ) ) != 0 ? 0xff : 0;
                Color32 c = new Color32( 0xff, 0xff, 0xff, ( byte )alpha );
                _texture.SetPixel( x * 8 + i, y, c );
            }
        }
    }
    _texture.Apply();
    return _texture;
}

static Texture2D _textureWithOutline;
public static Texture2D GetTextureWithOutline() {
    if ( _textureWithOutline ) {
        return _textureWithOutline;
    }

    _textureWithOutline = CreateTexture( ( APPLEIIF_CW + 1 ) * APPLEIIF_CLMS + 4,
                                                        ( APPLEIIF_CH + 2 ) * APPLEIIF_ROWS + 4);

    var colors = new Color32[_textureWithOutline.width * _textureWithOutline.height];

    Color32 white = new Color32(0xff, 0xff, 0xff, 0xff);
    Color32 clear = new Color32(0, 0, 0, 0);
    Color32 black = new Color32(0, 0, 0, 0xff);

    int srcW = APPLEIIF_WIDTH / 8;
    int row = 1;
    for ( int y = 0; y < APPLEIIF_HEIGHT; y++ ) {
        int column = 0;
        for ( int x = 0; x < srcW; x++ ) {
            int byt = bitmap[x + y * srcW];
            for ( int i = 0; i < 8; i++ ) {
                int xx = x * 8 + i;
                if ( ( xx % APPLEIIF_CW ) == 0 ) {
                    column++;
                }
                if ( ( byt & ( 1 << i ) ) != 0 ) {
                    colors[column + 1 + ( row + 0 ) * _textureWithOutline.width] = black;
                    colors[column + 1 + ( row + 1 ) * _textureWithOutline.width] = black;
                    colors[column + 0 + ( row + 1 ) * _textureWithOutline.width] = black;

                    colors[column - 1 + ( row - 0 ) * _textureWithOutline.width] = black;
                    colors[column - 1 + ( row - 1 ) * _textureWithOutline.width] = black;
                    colors[column - 0 + ( row - 1 ) * _textureWithOutline.width] = black;

                    colors[column + 1 + ( row - 1 ) * _textureWithOutline.width] = black;
                    colors[column - 1 + ( row + 1 ) * _textureWithOutline.width] = black;
                }
                column++;
            }
        }
        row++;
        if ( ( y % APPLEIIF_CH ) == APPLEIIF_CH - 1 ) {
            row += 2;
        }
    }

    row = 1;
    for ( int y = 0; y < APPLEIIF_HEIGHT; y++ ) {
        int column = 0;
        for ( int x = 0; x < srcW; x++ ) {
            int byt = bitmap[x + y * srcW];
            for ( int i = 0; i < 8; i++ ) {
                int xx = x * 8 + i;
                if ( ( xx % APPLEIIF_CW ) == 0 ) {
                    column++;
                }
                if ( ( byt & ( 1 << i ) ) != 0 ) {
                    colors[column + row * _textureWithOutline.width] = white;
                }
                column++;
            }
        }
        row++;
        if ( ( y % APPLEIIF_CH ) == APPLEIIF_CH - 1 ) {
            row += 2;
        }
    }

    _textureWithOutline.SetPixels32( colors );
    _textureWithOutline.Apply();
    return _textureWithOutline;
}

public static Texture2D CreateStringTexture( string s, int extraX = 0, int extraY = 0 ) {
    MeasureString( s, out float w, out float h, extraX: extraX, extraY: extraY );
    var tex = CreateTexture( ( int )( w + 0.5f ), ( int )( h + 0.5f ) );

    for ( int y = 0; y < tex.height; y++ ) {
        for ( int x = 0; x < tex.width; x++ ) {
            tex.SetPixel( x, y, new Color32( 0, 0, 0, 0 ) );
        }
    }

    int cx = 0;
    int cy = 0;
    int cw = APPLEIIF_CW + extraX;
    int ch = APPLEIIF_CH + extraY;
    foreach ( var c in s ) {

        if ( c == '\n' ) {
            cx = 0;
            cy += ch;
            continue;
        }

        int idx = c % ( APPLEIIF_CLMS * APPLEIIF_ROWS );

        int minU = ( idx % APPLEIIF_CLMS ) * APPLEIIF_CW;
        int minV = ( idx / APPLEIIF_CLMS ) * APPLEIIF_CH;

        for ( int y = 0; y < APPLEIIF_CH; y++ ) {
            for ( int x = 0; x < APPLEIIF_CW; x++ ) {
                int dstX = cx + x;
                int dstY = cy + y;
                int u = minU + x;
                int v = minV + y;

                int b = bitmap[( u >> 3 ) + v * ( APPLEIIF_WIDTH >> 3 )];
                b &= 1 << ( u & 7 );

                Color32 color = new Color32( 0xff, 0xff, 0xff, ( byte )( b != 0 ? 0xff : 0 ) );
                tex.SetPixel( dstX, tex.height - dstY - 1, color );
            }
        }

        cx += cw;
    }
    tex.Apply();
    return tex;
}

#if SDL
static IntPtr _sdlTexture;
public static IntPtr GetSDLTexture( IntPtr renderer ) {
    if ( _sdlTexture != null && _sdlTexture != IntPtr.Zero ) {
        return _sdlTexture;
    }
    SDL_SetHint( SDL_HINT_RENDER_SCALE_QUALITY, "0" );
    _sdlTexture = SDL_CreateTexture( renderer, SDL_PIXELFORMAT_ABGR8888, 
                    ( int )SDL_TEXTUREACCESS_STATIC, APPLEIIF_WIDTH, APPLEIIF_HEIGHT );
    int pitch = APPLEIIF_WIDTH * 4;
    int bw = APPLEIIF_WIDTH / 8;
    byte [] bytes = new byte[pitch * APPLEIIF_HEIGHT];
    for ( int y = 0, idx = 0; y < APPLEIIF_HEIGHT; y++ ) {
        for ( int x = 0; x < bw; x++ ) {
            int bt = bitmap[x + y * bw];
            for ( int i = 0; i < 8; i++, idx += 4 ) {
                int alpha = ( bt & ( 1 << i ) ) != 0 ? 0xff : 0;
                bytes[idx + 0] = 0xff;
                bytes[idx + 1] = 0xff;
                bytes[idx + 2] = 0xff;
                bytes[idx + 3] = ( byte )alpha;
            }
        }
    }
    IntPtr unmanagedPointer = Marshal.AllocHGlobal( bytes.Length );
    Marshal.Copy( bytes, 0, unmanagedPointer, bytes.Length );
    SDL_UpdateTexture( _sdlTexture, IntPtr.Zero, unmanagedPointer, pitch );
    return _sdlTexture;
}
#endif

static Texture2D CreateTexture( int w, int h ) {
    var tex = new Texture2D( w, h, textureFormat: TextureFormat.RGBA32,
                                                                mipChain: false, linear: false ); 
    tex.filterMode = FilterMode.Point;
    tex.hideFlags = HideFlags.HideAndDontSave;
    return tex;
}

}

#endif
